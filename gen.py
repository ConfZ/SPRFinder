from random import randint, random, choice
import argparse, os, sys, pdb
import settings

from instance import Instance
from copy import copy, deepcopy
from solver import run_command
import re
# from SMT_generator.generators.my_random_ast import random_ast
from SMT_generator.generators.random_ast import random_ast
from SMT_generator.generator import generate
from SMT_generator.transformers.bandit import bandit
from SMT_generator.constants import SMT_25_STRING
from SMT_generator.parser import parse
import tempfile as tmpf
import SMT_generator.generators.random_ast_zy as zy


class Generator_Str:
    num = 0

    def __init__(self):
        self.ops = settings.string_ops
        self.re_set = [re.compile('\(set-info.*'), re.compile('Generated by:.*'), re.compile('Generated on:.*'),
                       re.compile('Generator:.*'), re.compile('Application:.*'), re.compile('Target solver:.*'),
                       re.compile('\|\)'), re.compile('Publication:\n.*\n.*')]
        self.reg = re.compile('str\.[a-z]*_[a-z]*')

    def gen(self):
        print(os.getcwd())
        # smt = random_ast(num_vars=20, int_num=4, bool_num=2, num_asserts=settings.num_assertions,
        #                  depth=settings.GeneratorMaxDepth, max_terms=5, max_str_lit_length=10, max_int_lit=10,
        #                  semantically_valid=True, literal_probability=0.1)
        smt, statistics = zy.random_ast(max_var_num = settings.max_var_num, max_terms = settings.max_assert_num, max_depth=settings.max_depth, max_str_lit_length=settings.max_str_len, max_int_lit=200, literal_probability=0.1, new_var_probability=0.5,
                        op_weight=settings.op_dict,semantically_valid=False)
        smt = generate(smt, SMT_25_STRING)

        if smt.count('(set-logic QF_S)') == 0 and smt.count('(set-logic QF_SLIA)') == 0:
            if settings.theory == 'QF_S':
                smt = '(set-logic QF_S)\n' + smt
            elif settings.theory == 'QF_SLIA':
                smt = '(set-logic QF_SLIA)\n' + smt
        # print('cmd:',cmd)
        # print('end')
        assert smt != 'err' or smt != 'timeout' or smt != 'empty', smt
        assert smt.count('assert') > 0, smt

        return Instance(smt, statistics)

    def form(self, smt):
        op = re.findall(self.reg, smt)
        op = list(set(op))
        nop = [R.replace('_', '.') for R in op]
        for i in range(len(nop)):
            smt = smt.replace(op[i], nop[i])
        return smt

    def get_case(self):
        file = settings.InputFiles[Generator_Str.num]
        filehandle = open(file, 'r')
        smt = filehandle.read()
        filehandle.close()
        Generator_Str.num += 1
        assert Generator_Str.num <= len(settings.InputFiles), 'all the cases is down'
        if settings.theory == 'QF_S':
            smt = smt.replace('(set-logic QF_SLIA)', '(set-logic QF_S)')
        elif settings.theory == 'QF_SLIA':
            smt = smt.replace('(set-logic QF_S', '(set-logic QF_SLIA)')
        else:
            assert False, 'theory out of scope'
        if smt.count('(set-logic QF_S)') == 0 and smt.count('(set-logic QF_SLIA)') == 0:
            if settings.theory == 'QF_S':
                smt = '(set-logic QF_S)\n' + smt
            elif settings.theory == 'QF_SLIA':
                smt = '(set-logic QF_SLIA)\n' + smt
        for R in self.re_set:
            smt = re.sub(R, '', smt, count=0)
        smt = self.form(smt)
        assert smt != 'err' or smt != 'timeout' or smt != 'empty', smt
        assert smt.count('assert') > 0, smt

        return Instance(smt)

    def mutate(self, instance, action):

        # fname = '/tmp/' + instance.name
        # instance.to_file('/tmp/')
        # cmd   =  r'/home/zy/Documents/workplace/generator_cvc4/BanditFuzz_Public_cvc4/banditfuzz/SMT_generator/bin/stringfuzzx --file ' + fname + ' '
        # cmd  += '--random '
        # cmd  += 'bandit --operator \'' + action + '\''

        # cmd += '--num-asserts ' + str(settings.NumPrimaries) + ' '
        # cmd += '--num-vars ' + str(settings.GeneratorNumConst) + ' '
        # cmd += '-o ' + "".join([v+ ',' for v in settings.string_ops])
        print("Mutated with the following action: " + action)

        loop_count = 0
        smt = ''
        statis = instance.statistics
        while True:
            loop_count += 1
            if loop_count > 100:
                print("Too many failed transformations")
                raise ValueError
            try:
                smt = generate(bandit(parse(instance.primaries, SMT_25_STRING), action, 2), SMT_25_STRING)
                if smt.count('(set-logic QF_S)') == 0 and smt.count('(set-logic QF_SLIA)') == 0:
                    if settings.theory == 'QF_S':
                        smt = '(set-logic QF_S)\n' + smt
                    elif settings.theory == 'QF_SLIA':
                        smt = '(set-logic QF_SLIA)\n' + smt
                assert smt != 'err' or smt != 'timeout' or smt != 'empty'
                assert smt.count('assert') > 0

                break
            except Exception as e:
                print('exception:', e)
                print("On input1:")
                print(instance)
                print("On action:", action)
                print("Outputed illegal smt2 file:")
                print(smt)

        return Instance(smt, statis)


def mk_gen():
    return Generator_Str()
    # print(settings.theory)
    # assert settings.theory == 'QF_FP'
    #
    # width = settings.FloatWidth
    # ne = 0
    # ns = 0
    # if width == 5:
    #     ne = 2
    #     ns = 3
    # elif width == 32:
    #     ne = 8
    #     ns = 24
    # elif width == 64:
    #     ne = 11
    #     ns = 53
    # elif width == 128:
    #     ne = 15
    #     ns = 113
    # elif width == 256:
    #     ne = 19
    #     ns = 237
    # else:
    #     if width < 32:
    #         ne = round(width * 8 / 24)
    #         ns = width - ne
    #     elif width < 64:
    #         ne = round(width * 11 / 53)
    #         ns = width - ne
    #     elif width < 128:
    #         ne = round(width * 15 / 113)
    #         ns = width - ne
    #     else:
    #         ne = round(width * 19 / 237)
    #         ns = width - ne
    #
    # ops = []
    #
    # if settings.FP_Abs:
    #     ops.append("fp.abs")
    # if settings.FP_Neg:
    #     ops.append("fp.neg")
    # if settings.FP_Add:
    #     ops.append("fp.add")
    # if settings.FP_Sub:
    #     ops.append("fp.sub")
    # if settings.FP_Mul:
    #     ops.append("fp.mul")
    # if settings.FP_Div:
    #     ops.append("fp.div")
    # if settings.FP_FMA:
    #     ops.append("fp.fma")
    # if settings.FP_Rem:
    #     ops.append("fp.rem")
    # if settings.FP_R2I:
    #     ops.append("fp.roundToIntegral")
    # if settings.FP_Sqrt:
    #     ops.append("fp.sqrt")
    # if settings.FP_Min:
    #     ops.append("fp.min")
    # if settings.FP_Max:
    #     ops.append("fp.max")
    # if settings.FP_Leq:
    #     ops.append("fp.leq")
    # if settings.FP_Lt:
    #     ops.append("fp.lt")
    # if settings.FP_Geq:
    #     ops.append("fp.geq")
    # if settings.FP_Gt:
    #     ops.append("fp.gt")
    # if settings.FP_Eq:
    #     ops.append("fp.eq")
    # if settings.FP_IsNorm:
    #     ops.append("fp.isNormal")
    # if settings.FP_IsSub:
    #     ops.append("fp.isSubnormal")
    # if settings.FP_IsZero:
    #     ops.append("fp.isZero")
    # if settings.FP_IsNan:
    #     ops.append("fp.isNaN")
    # if settings.FP_IsNeg:
    #     ops.append("fp.isNegative")
    # if settings.FP_IsPos:
    #     ops.append("fp.isPositive")
    #
    # rounding_modes = []
    # if settings.FP_RNE:
    #     rounding_modes.append("RNE")
    # if settings.FP_RNA:
    #     rounding_modes.append("RNA")
    # if settings.FP_RTP:
    #     rounding_modes.append("RTP")
    # if settings.FP_RTN:
    #     rounding_modes.append("RTN")
    # if settings.FP_RTZ:
    #     rounding_modes.append("RTZ")
    #
    # return Generator(ops, rounding_modes, ne, ns)
